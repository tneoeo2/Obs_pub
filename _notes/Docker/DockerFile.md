---
created: 2024-04-08 14:30
updated: 2024-04-08 14:30
tags:
  - docker
  - dockerfile
  - dockercompose
---
## DockerFile
- [DockerFile ref_공식문](https://docs.docker.com/reference/dockerfile/)
`Dockerfile`은 도커 이미지를 구축하기 위해 명령어들을 순차적으로 나열한 텍스트 파일이다. 각각의 명령어는 이미지의 새로운 계층을 만들어 내며, 이러한 계층들이 합쳐져 최종적인 이미지를 형성한다. 

### DockerFile 작성하기
###### 1단계: Maven 또는 Gradle을 사용하여 Spring Boot 애플리케이션 빌드
```shell
FROM maven:3.6.3-jdk-11 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -f pom.xml clean package
```
>. Maven 기반 이미지를 사용하여 소스 코드를 컨테이너 내부로 복사하고, Maven을 사용해 애플리케이션을 빌드
###### 2단계: JAR 파일을 실행하기 위한 새로운 레이어
```shell
FROM openjdk:11
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
```
> OpenJDK 기반 이미지를 사용하여 빌드 단계에서 생성된 JAR 파일을 복사하고, Java 애플리케이션을 실행

#### 기본 구조 및 명령어
- _FROM_ : 기반 이미지를 지정. 모든 `Dockerfile`은 `FROM` 명령어로 시작해야하며, 이는 빌드 과정의 기점이 되는 이미지를 정의 한다.
- _LABEL_ : 이미지에 메타데이터를 추가
	- 이미지의 제작자 정보 등을 포함할 수 있다.
	- `LABEL maintainer="name@example.com`
- _RUN_ : 이미지 빌드 과정 중에 명령어를 실행
	- 주로 패키지 설치나 설정 파일 변경에 사용
	- `RUN apt-get update && apt-get install -y python`
- _COPY_ : 호스트 파일이나 디렉토리를 이미지 내부로 복사
	- 애플리케이션의 소스 코드를 이미지에 추가할 때 주로 사용
	- `COPY . /app`
- _ADD_ : COPY 명령어와 유사하지만 원격 URL에서 파일을 추가하거나 로컬의 압축 파일을 압축 해제하며 파일을 추가할 수 있다.
	- `ADD https://example.com/big.tar.xz /usr/src/things/`
- _CMD_ : 컨테이너가 시작될 때 실행할 기본 명령어를 정의한다.
	- Dockerfile 내에서 한 번만 사용 가능
	- `CMD ["python", "./app/app.py"]`
- _EXPOSE_ : 컨테이너가 리스닝할 포트를 지정
	- 네트워킹 구성에 도움을 준다.
	- `EXPOSE 80`
- _ENV_: 환경 변수를 설정. 애플리케이션 설정에 사용된다.
	- `ENV API_KEY="YOUR_API_KEY"`
- _WORKDIR_: RUN , CMD , ENTRYPOINT , COPY , ADD 명령어가 실행될 작업 디렉토리를 설정한다.
	- `WORKDIR /app`
- _ENTRYPOINT_: 컨테이너가 시작될 때 실행할 명령어를 설정한다. CMD 와 함께 사용되어 애플리케이션의 실행 방식을 정의할 수 있다.
```shell
ENTRYPOINT ["python"]
CMD ["app.py"]
```

-> Dockerfile을 준비한 후, `docker build` 명령어를 통해 이미지를 빌드할 수 있다. 이때 Dockerfile 내의 지시어들이 순서대로 실행되어 최종 이미지가 생성된다.
Dockerfile을 활용함으로써 애플리케이션의 빌드와 배포과정을 표준화하고 자동화 할 수 있으며, 개발 효율성을 높이는데 기여한다.


## 실제 배포 체크 포인트
#### 도커 이미지 최적화
도커 이미지의 크기를 줄이기 위한 Dockerfile 최적화 전략에는 여러 방법이 있다. 이미지의 효율성을 높이고, 배포 시
간을 단축하며, 보안을 강화하는 데 중요하다.
- _경량 베이스 이미지 사용_
	- 가능한 가장 경량의 베이스 이미지를 사용
	- ex) `alpine` 이미지는 매우 작은 크기로 필요한 최소한의 기능만 포함한다.
- _멀티 스테이지 빌드 사용_
	- Dockerfile에서 멀티 스테이지 빌드를 사용하여 빌드 단계에만 필요한 도구를 최종 이미지에서 제외시킨다.
	- 최종 이미지에는 애플리케이션 실행에 필요한 파일과 디펜던시만 포함된다.
	- 여러 개의 FROM 명령어를 사용하여 구현되며, 각 스테이지는 독립적인 베이스 이미지를 가질 수 있다. 
	- 첫번 째 스테이지에서는 빌드에 필요한 도구와 소스코드를 컴파일하는데 필요한 작업을 수행한다. 이후 스테이지에서는 첫번째 스테이지에서 생성된 아티팩트만을 가져와서 최종이미지를 생성한다. 
	- 불필요한 빌드 도구나 중간 생성물을 최종이미지에서 제외할 수 있어 이미지 크기가 상당히 줄어든다.
- _필요 없는 파일 제거_
	- 빌드 과정에서 생성되는 임시파일, 캐시 파일 등 필요없는 파일은 `RUN` 명령어에서 `&& rm -rf /path/to/tem/files`와 같이 제거하여 이미지 크기를 줄인다.
- _레이어 수 최소화
	- RUN, COPY, ADD 명령어는 새로운 레이어를 생성한다. 이러한 명령어를 적절히 조합하여 가능한 적은 수의 레이어를 생성하도록 Dockerfile을 최적화한다.
- _COPY와 ADD 명령어 신중히 사용_
	- COPY와 ADD는 필요한 파일만 이미지에 추가하도록 사용
	- `.dockerignore`파일을 사용하여 불필요한 파일이 이미지에 포함되지 않도록 설정할 수 있다.
- _환경 변수를 이용한 설정_
	- 가능한 설정 파일 대신 환경 변수를 사용하여 애플리케이션을 구성
	- 설정 변경이 필요할 때 이미지를 다시 빌드하지 않아도 되므로 이미지 크기를 줄이는데 도움이 된다.
- _적절한 태그 사용_
	- 필요한 소프트웨어의 적절한 버전을 지정하여 불필요한 업데이트로 인한 크기 증가를 피한다.

-> 이러한 전략들을 적용함으로써 도커 이미지 크기를 줄이고 배포 및 실행 시간을 단축시키며, 보안을 강화할 수 있다.


#### 실제 배포를 위해 컨테이너-호스트 간 파일 복사
https://docs.docker.com/reference/cli/docker/container/cp/
![[Pasted image 20240408151631.png]]
- `docker cp`명령어는 실행 중인 도커 컨테이너와 호스트 사이에서 파일이나 디렉토리를 복사하는 데 사용된다. 
	- 컨테이너의 파일 시스템과 호스트의 파일 시스템간의 데이터를 쉽게 이동할 수 있게 해줌
	- `컨테이너 이름` 대신 `컨테이너 ID` 사용 가능
	- 디렉토리 복사시 대렉토리 내의 모든 파일과 하위 디렉토리 함께 복사됨
	- 로그파일, 설정 파일, 애플리케이션 데이터 등 컨테이너 내부나 외부에서 필요한 데이터를 쉽게 이동시키는 데 유용하다.
	- 컨테이너의 실행 중인 서비스에 필수적인 파일을 변경, 삭제할 때는 주의 필요

- _호스트에서 컨테이너로 파일이나 디렉토리 복사하기_
	`docker cp <호스트의 파일 경로> <컨테이너 이름>:<컨테이너 내 경로>`
	> `docker cp myfile.txt mycontainer:/usr/src/app/myfile.txt`
	> -> `myfile.txt`를 mycontainer라는 이름의 컨테이너의 `/usr/src/app` 디렉토리로 복사한다.

- _컨테이너에서 호스트로 파일이나 디렉토리 복사하기_
`docker cp <컨테이너 이름>:<컨테이너 내 파일 경로> <호스트의 경로>`
>`docker cp mycontainer:/usr/src/app/myfile.txt ./myfile.txt
>-> mycontainer 컨테이너의 /usr/src/app/myfile.txt 를 호스트의 현재 작업 디렉토리로 복사


### Docker compose 
[springboot와 frontend Docker로 배포하기-지마켓 공식블로그](https://dev.gmarket.com/80)
 도커 컴포즈(Docker compose)는 여러 컨테이너를 정의하고 실행하기 위한 도구다.
YAML 파일을 사용하여 애플리케이션 서비스, 네트워크, 볼륨 등을 구성하며 이 파일을 기반으로 한 명령어로 모든 서비스를 빌드하고 시작할 수 있다. 
 도커 컴포즈는 복잡한 멀티 컨테이너 애플리케이션을 쉽게 관리, 개발, 테스팅, 스테이징, 프로덕션 환경에서의 일관성을 보장하는 데 유용하다.
#### Docker compose 주요 특징
1. **간편한 구성** : `docker-compose.yml` 파일 하나로 전체 애플리케이션 스택의 설정을 관리할 수 있다. 이 YAML 파일에는 애플리케이션을 구성하는 모든 컨테이너, 그 컨테이너들이 사용할 이미지, 포트 매핑, 볼륨, 마운트, 환경 변수 등이 정의된다.
2. **명령어 단순화** : `docker-compose up`, `docker-compose down` 같은 간단한 명령어를 통해 서비스를 생성, 시작, 중지할 수 있다.  -> 개발 과정 효율적으로 만들어준다.
3. **개발 효율성 증대** : 개발자는 로컬 환경에서 전체 애플리케이션을 손쉽게 시뮬레이션하고 테스트 할 수 있다. 컨테이너화된 환경 덕분에 다른 개발자나 환경과의 충돌없이 독립적으로 작업할 수 있다.
4. **환경 일관성 보장** : 도커 컴포즈를 사용하면 개발부터 프로덕션까지 애플리케이션의 환경을 일관되게 유지할 수 있다. (개발 환경에선 됐는데... 문제방지)
5. **다중 서비스 관리** : 복잡한 애플리케이션을 구성하는 다수의 서비스(ex. 데이터베이스, 백엔드, 프론트엔드 등)를 한번에 관리할 수 있다. 각 서비스는 독립적인 컨테이너로 실행되지만, 도커 컴포즈를 통해 서로 연결되고 조율된다.

-> 도커 컴포즈는 개발 초기 단계에서부터 애플리케이션의 배포까지 전 과정에서 개발자의 작업을 `단순화`하고 `가속화`하는 효율적인 도구다.

#### Docker compose 기본 구조
 도커 컴포즈 파일은 여러 도커 컨테이너를 정의하고 실행하기 위한 YAML형식의 설정 파일이다. 이 파일을 통해 서비스, 네트워크, 볼륨 등을 정의하고 관리할 수 있다.
- **버전 (version)**
	도커 컴포즈 파일의 버전을 명시한다. 버전에 따라 사용할 수 있는 구성 옵션이 다르며, 일반적으로 최신 버전을 사용하는 것이 좋다.
	```shell
version: '3'
	```
	
-	 **서비스 (services)**
	애플리케이션을 구성하는 컨테이너들을 정의. 각 서비스는 하나의 컨테이너를 의미하며, 도커 이미지, 포트 바인딩, 볼륨 마운트 등 컨테이너를 실행하기 위한 설정을 포함한다.
	```shell
services:
	web:
	image: nginx
	ports:
	- "8080:80"
	db:
	image: postgres
	volumes:
	- db-data:/var/lib/postgresql/data
```


- __네트워크 (networks)__
  컨테이너 간 통신을 위한 네트워크를 정의한다. 사용자 정의 네트워크를 생성하여 서비스들이 통신할 수 있는 네트워크 환경을 구성할 수 있다.
     ```shell
networks:
	app-network:
	```


- __볼륨 (volumes)__
	데이터를 영구적으로 저장하기 위한 볼륨을 정의한다. 볼륨은 컨테이너가 삭제되어도 데이터를 보존하며, 여러 컨테이너 간에 데이터를 공유할 수 있도록 한다.
```shell
volumes:
	db-data:
```

- **기타 구성 요소**
    - 환경 변수 (environment), 컨테이너 종속성(depends_on), 컨테이너 구성 옵션 (configs), 비밀 키(secrets) 등 추가적인 구성요소를 정의하여 더욱 복잡한 애플리케이션을 관리할 수 있다.
    - 도커 컴포즈 파일을 사용하면 여러 컨테이너로 구성된 애플리케이션을 한 곳에서 관리할 수 있으며, `docker-compose up`명령어 하나로 모든 서비스를 시작하고, `docker-compose down`명령어로 중지시킬 수 있다. -> 애플리케이션 배포와 관리 과정 간소화
---
[docker-compose 템플릿](https://github.com/docker/awesome-compose)


#### Volumes
container는 불변하지 않는다. 한번 사용되는 개념으로 인스턴스와 유사하다.
![[Pasted image 20240409000227.png]]
- persistence 해야하는 데이터는 어떻게 해야하나?

- 도커에서 스토리지 관리 측면에서 볼륨은 데이터를 영구적으로 저장하고 관리하기 위한 메커니즘을 제공한다. 컨테이너는 기본적으로 일시적이며 상태가 없기 때문에,
  컨테이너 내부에 저장된 데이터는 컨테이너가 삭제될 때 함께 사라진다. 
  볼륨을 사용하여 이런 문제를 해결할 수 있으며 데이터를 컨테이너의 생명주기와 독립적으로 보존할 수 있다.
- 도커 호스트의 파일 시스템에 위치, 하나 이상의 컨테이너에 마운트되어 사용될 수 있다.

##### 볼륨 사용의 이점
- __데이터의 영구성__: 볼륨에 저장된 데이터는 컨테이너가 삭제되어도 보존된다. 따라서 중요한 데이터를 안전하게 관리할 수 있다.
- __데이터 공유 및 재사용__: 볼륨은 여러 컨테이너 간에 마운트되어 공유될 수 있어, 다양한 컨테이너에서 동일한 데이터에 접근하거나 데이터를 재사용할 수 있다.
- __데이터 백업, 복구 및 마이그레이션__: 볼륨을 사용하면 데이터를 백업하고 필요할 때 복구하는 것이 용이하다. 또한, 볼륨을 이용해 데이터를 한 호스트에서 다른 호스트로 쉽게 이동할 수 있다.

##### 볼륨 관련 명령어
- `docker volume create` : 새로운 볼륨을 생성
- `docker volume ls` : 생성된 볼륨 목록을 조회
- `docker volume rm` : 지정한 볼륨을 삭제
- `docker volume inspect` : 지정한 볼륨의 상세 정보를 조회
- `docker run ` : 볼륨을 컨테이너에 마운트 
	- `-v`
	- `--mount`
	- ex)  `docker run -v myvolume:/app <이미지 이름>` : `myvolume `이라는 이름의 볼륨을 컨테이너의 `/app `디렉토리에 마운트
---
###### volume
컴퓨터 과학(CS)에서 볼륨은 데이터 저장 공간을 의미하는 용어로 사용된다. 일반적으로, 볼륨은 하드 드라이브, SSD, 또는 네트워크에 연결된 스토리지 시스템에서 데이터를 저장하는 데 사용되는 논리적인 파티션이나단위를 가리킨다. 볼륨은 파일 시스템을 포함할 수 있으며, 운영 체제는 볼륨을 통해 데이터에 접근하고 관리한다.
볼륨은 물리적인 스토리지 디바이스를 논리적으로 구분하여 관리할 수 있게 해주며, 다음과 같은 목적으로 사용될 수 있다:

- _데이터 조직화_: 볼륨을 사용하면 데이터를 더욱 체계적으로 조직화하고 관리할 수 있다. 예를 들어, 사용자 데이터, 애플리케이션 데이터, 백업 등을 서로 다른 볼륨에 저장하여 관리할 수 있다.
- _보안 및 접근 제어_: 볼륨 단위로 보안 정책과 접근 제어를 설정함으로써 데이터 보안을 강화할 수 있다.
- _백업 및 복구_: 볼륨은 백업과 복구 작업을 용이하게 한다. 특정 볼륨만을 대상으로 백업하거나 복구함으로써, 효율적으로 데이터를 보호할 수 있다.
- _성능 최적화_: 데이터를 여러 볼륨에 분산시키면, I/O 작업의 부하를 분산시켜 전체 시스템의 성능을 향상시킬 수 있다.
  
볼륨 관리는 운영 체제나 스토리지 관리 소프트웨어를 통해 이루어진다. 현대의 운영 체제는 볼륨을 생성하고,포맷하며, 마운트하는 기능을 제공한다. 클라우드 컴퓨팅 환경에서는 볼륨을 가상화하여, 필요에 따라 동적으로 스토리지 용량을 확장하거나 축소할 수 있는 기능도 제공한다.

데이터베이스 시스템, 웹 서버, 파일 서버 등 다양한 애플리케이션과 시스템에서 볼륨은 중요한 데이터 관리 도구로 활용된다. 볼륨을 효과적으로 사용함으로써 데이터의 안정성, 접근성, 시스템의 전반적인 성능을 향상시킬 수 있다. 

---
##### 스토리지 마운트 방법
스토리지 마운트에는 두가지 방법을 크게 사용한다.
- 바인드 마운트
- 볼륨 마운트

###### 바인드 마운트 (Bind Mount)
https://docs.docker.com/guides/walkthroughs/persist-data/
- _정의_: 바인드 마운트는 `호스트 시스템의 특정 경로를 컨테이너 내부의 경로에 직접 연결`하는 방법이다. 이를 통해 컨테이너가 호스트 시스템의 파일이나 디렉토리에 접근할 수 있다.
- _특징_: 개발 환경에서 코드나 데이터를 빠르게 반복해서 테스트할 때 유용하다. 파일 시스템의 특정 부분만 컨테이너와 공유하려는 경우에 적합하다.
- _주의점_: 바인드 마운트는 호스트 시스템의 파일 시스템 구조에 의존하므로, 이식성이 떨어진다.
```shell
#호스트의 현재 디렉토리에 있는 index.html 파일을 Nginx 컨테이너의 /usr/share/nginx/html 경로에 배치
docker run --name my-nginx -v $(pwd):/usr/share/nginx/html:ro -p 8080:80 -d nginx
```

###### 볼륨 (Volume)
- _정의_: 볼륨은 도커가 관리하는 데이터의 저장소이다. `컨테이너와 독립적으로 존재`하여 데이터를 보관할 수 있고, 하나 이상의 컨테이너에서 사용할 수 있다.
- _특징_: 볼륨은 도커가 관리하기 때문에 이식성이 높고, 데이터를 안전하게 보관할 수 있다. 여러 컨테이너 간에 데이터를 공유하거나 데이터의 지속적인 저장이 필요한 경우에 적합하다.
- _주의점_: 볼륨은 도커의 관리 하에 있기 때문에, 호스트 시스템의 파일 시스템 경로를 직접 지정할 수 없다.
```shell
#볼륨을 사용하여 index.html 파일을 Nginx 컨테이너에 배치

1. 볼륨 생성
docker volume create my-nginx-volume 

2. 호스트의 index.html 파일을 볼륨에 복사한다. 이 작업은 직접적으로 가능하지 않으므로, 임시 컨테이너를 사용해 볼륨에 파일을 복사할 수 있다.
3. 볼륨을 Nginx 컨테이너에 마운트하여 실행한다.
docker run --name my-nginx -v my-nginx-volume:/usr/share/nginx/html -p 8080:80 -d nginx
```
>일반적으로 초기 컨테이너 설정이나 Dockerfile을 통해 이루어진다. 바인드 마운트의 경우처럼 간단하게 파일을 컨테이너에 넣을 수 없기 때문에 볼륨을 사용할 때는 파일을 볼륨에 미리 넣거나 컨테이너 내부에서 파일을 다운로드하는 등의 방법을 사용해야한다.


#### Docker 이미지 같이 사용하기
- Docker hub pull & push 에서 이미지 가져오기/업로드하기
- `docker login` : 도커 계정에 로그인
	- docker hub에 계정 있어야하며, 도커가 설치되어 있어야함.

##### 과정
1. 이미지 끌어오기
   - `docker pull <이미지 이름>` : Docker Hub에서 이미지를 로컬 시스템으로 끌어온다.
2. 이미지에 새로운 태그 붙이기
   - `docker tag <이미지 이름>:latest <your-docker-hub-username>/nginx:<tag>` :
     - `<your-docker-hub-username> `: Docker Hub 사용자 이름
     - `<tag>`:  원하는 태그명
3. Docker Hub저장소에 이미지 올리기전 로그인
   - `docker login` : Docker Hub에 로그인
4. 이미지 올리기
   - `docker push <your-docker-hub-username>/nginx:<tag>docker push` : 새로운 태그를 붙인 이미지 docker hub에 올리기

#### Network
서로 다른 컨테이너를 연결하려면 가상 네트워크를 만들고 네트워크에 컨테이너를 소속시켜 컨테이너를 연결해야한다.

##### 컨테이너 연결시키기
> ex) 레드마인 + mysql 연결시키기
1. _사용자 정의 네트워크 생성_
   - `docker network create redmine-network
    사용자 정의 도커 네트워크를 생성한다.
2. _MySQL컨테이너 실행_
   ex) 사용자 정의 네트워크에 MySQL 컨테이너를 실행, 데이터 베이스 준비
   - `docker run --name some-mysql --network redmine-network -e MYSQL_ROOT_PASSWORD=mysecret-pw -e MYSQL_DATABASE=redmine -d mysql:8`
	MySQL 8 이미지를 사용하여 some-mysql 이라는 이름의 컨테이너를 생성하고, 사용자 정의 네트워크 redmine-network 에 연결한다. 또한, MySQL 데이터베이스의 루트 비밀번호( MYSQL_ROOT_PASSWORD )와 레드마인이 사용할 데이터베이스 이름( MYSQL_DATABASE )을 설정한다.
3. _레드마인 컨테이너 실행_
   - `docker run --name some-redmine --network redmine-network -e REDMINE_DB_MYSQL=some-mysql -e REDMINE_DB_PASSWORD=my-secret-pw -p 3000:3000 -d redmine`
     MySQL 데이터베이스에 연결된 레드마인 컨테이너를 실행한다. 레드마인 컨테이너 역시 사용자 정의 네트워크에 연결해야 한다
     이 명령어는 redmine 이미지를 사용하여 some-redmine 이라는 이름의 컨테이너를 실행하고, redmine-network 네트워크에 연결한다. 
     MySQL 데이터베이스에 접근하기 위한 정보( REDMINE_DB_MYSQL , REDMINE_DB_PASSWORD )를 환경 변수로 설정한다.
      마지막으로, 호스트의 3000 포트를 컨테이너의 3000 포트에 매핑하여 외부에서 레드마인에 접근할 수 있도록 한다.
   
	--> `http://localhost:3000 `에 접속하면 레드마인의 홈페이지에 접근할 수 있다. 레드마인과 MySQL 컨테이너가 성공적으로 연결되어 있으며, 데이터베이스 설정이 올바르게 구성되어 있다면, 레드마인을 사용하여 프로젝트 관리 작업을 시작할 수 있다.

#### Docker network 종류
- 브릿지 네트워크 먼저 핵심 포인트! 나머지는 Devops 의 영역!
- 도커 네트워크는 컨테이너 간의 통신과 외부 네트워크와의 연결을 관리하는 도커의 기능이다. 이를 통해 개발자는 컨테이너가 서로 어떻게 통신할 수 있는지, 어떤 정책으로 네트워크를 격리할 것인지를 정의할 수 있다. 도커 네트워크는 여러 네트워크 드라이버를 지원하며, 각각의 사용 사례에 따라 적합한 네트워크 환경을 구성할 수 있다.

##### 1. 브리지 네트워크 (Bridge Network)
- _정의_: 기본적으로, 각 도커 설치에는 하나의 브리지 네트워크가 존재하며, 컨테이너를 실행할 때 이 네트워크에 자동으로 연결된다. 사용자는 여러 개의 사용자 정의 브리지 네트워크를 생성하여 컨테이너를 논리적으로 분리할 수 있다.
- _사용 사례_: 같은 브리지 네트워크에 속한 컨테이너끼리는 서로 통신할 수 있지만, 다른 브리지 네트워크에 속한 컨테이너와는 통신할 수 없다. 이를 통해 애플리케이션의 컴포넌트를 격리할 수 있다.
  ![[Pasted image 20240409005347.png]]
  
  ![[Pasted image 20240409005426.png]]
  - 브리지 네트워크는 도커 컨테이너들이 `동일한 호스트 내에서 서로 통신할 수 있는 기본 네트워크 타입` 중 하나
  - 가상의 브리지(bridge)를 통해 각 컨테이너를 연결하여 이를 통해 컨테이너간 데이터를 주고 받을 수 있다.
  - 브릿지 네트워크는 컨테이너가 생성될 때 자동으로 생성되는 `기본 네트워크(bridge)`와 사용자가 직접 생성할 수 있는 `정의 브릿지 네트워크`로 구분된다.
###### 브릿지 네트워크 장점
- __컨테이너 간 통신__: 브릿지 네트워크를 사용하면, 같은 호스트 내의 컨테이너들이 서로 통신할 수 있다.
- __네트워크 격리__: 서로 다른 브릿지 네트워크에 속한 컨테이너들은 기본적으로 서로 통신할 수 없으며, 이를 통해 네트워크 격리를 구현할 수 있다.
- __DNS 해석__: 사용자 정의 브릿지 네트워크는 컨테이너 이름을 DNS 이름으로 사용할 수 있게 해주어, IP 주소 대신 컨테이너 이름으로 통신할 수 있다.

> 브릿지 네트워크는 도커에서 가장 기본적이면서도 중요한 네트워크 타입중 하나로, 컨테이너화된 애프리케이션의 통신 구조를 효과적으로 구성할 수 있다.

###### 브리지 네트워크 종류
1. __기본 브리지 네트워크__
- 도커를 설치하면 기본적으로 bridge 라는 이름의 브릿지 네트워크가 생성된다.
  - 기본 브릿지 네트워크에 연결된 컨테이너는 호스트의 네트워크와는 격리되어 있지만, 같은 네트워크 내의 다른 컨테이너와는 통신할 수 있다.
- 기본 브릿지 네트워크를 사용하는 컨테이너는 -p 또는 --publish 옵션을 사용하여 호스트와 특정 포트를 연결하지 않는 이상 외부 네트워크와 직접 통신할 수 없다.

2.  __사용자 정의 브릿지 네트워크__
- 사용자는 docker network create 명령어를 사용하여 추가 브릿지 네트워크를 생성할 수 있다.
- 사용자 정의 브릿지 네트워크는 기본 브릿지 네트워크보다 여러 가지 장점이 있다. 예를 들어, 자동 DNS 해석 기능을 통해 컨테이너 이름을 사용하여 서로 통신할 수 있게 된다.
- 사용자 정의 브릿지 네트워크에 연결된 컨테이너는 보다 `높은 수준의 네트워크 격리와 보안`을 제공받을 수 있다.

##### 2. 호스트 네트워크 (Host Network)
- _정의_: 호스트 네트워크를 사용하면 컨테이너가 호스트의 네트워크 스택을 직접 사용할 수 있다. 이 방식을 사용하면 컨테이너는 네트워크 격리 없이 호스트와 동일한 네트워크 환경을 공유한다.
- _사용 사례_: 네트워크 격리보다 네트워크 성능을 우선시하는 경우에 적합하다. 예를 들어, 최대한의 네트워크 성능이 요구되는 고성능 웹 서버에 사용할 수 있다.

##### 3. 오버레이 네트워크 (Overlay Network)
- _정의_: 오버레이 네트워크는 여러 도커 호스트에 걸쳐 있는 컨테이너 간의 통신을 가능하게 한다. 이 네트워크는 스웜모드에서 클러스터링된 도커 환경을 위해 설계되었다.
- _사용 사례_: 다중 호스트 컨테이너 오케스트레이션을 필요로 하는 대규모 애플리케이션에 적합하다. 오버레이 네트워크는 컨테이너 간의 안전한 통신을 위해 내부적으로 암호화를 지원한다.

##### 4. 맥바이란 네트워크 (Macvlan Network)
- _정의_: 맥바이란 네트워크는 컨테이너에 별도의 MAC 주소를 할당하여, 물리 네트워크에 직접 연결된 것처럼 만든다. 이를 통해 컨테이너가 네트워크 상에서 물리적인 장치처럼 동작할 수 있다.
- _사용 사례_: 기존의 VLAN에 컨테이너를 통합해야 하는 경우나, 컨테이너가 물리 네트워크 상의 다른 장치들과 통신해야 하는 경우에 사용한다.

>도커 네트워크를 사용함으로써, 컨테이너화된 애플리케이션의 네트워킹 요구사항을 유연하게 충족시킬 수 있으며, 애플리케이션의 구성 요소 간에 효과적으로 통신 구조를 설정할 수 있다.

